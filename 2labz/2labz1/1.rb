def min_operations(target)
  # Преобразуем строку в массив символов
  chars = target.chars.to_a
  # Получаем длину целевой последовательности
  n = chars.size
  
  # Создаем массив для хранения минимального количества операций
  dp = (0..n).to_a
  # Флаг для отслеживания использования операции удвоения
  used_double = false

  # Заполняем массив dp значениями
  (1..n).each do |i|
    # Базовый случай - добавление одного символа
    dp[i] = dp[i - 1] + 1
    
    # Проверяем возможность операции удвоения
    if !used_double && i.even?
      # Вычисляем половину длины
      half = i / 2
      # Флаг для проверки возможности удвоения
      can_double = true
      
      # Проверяем совпадение символов в двух половинах
      (0...half).each do |j|
        if chars[j] != chars[half + j]
          can_double = false
          break
        end
      end
      
      # Если можно удвоить и это выгодно
      if can_double && dp[half] + 1 < dp[i]
        # Обновляем значение в dp
        dp[i] = dp[half] + 1
        # Помечаем удвоение как использованное
        used_double = true
      end
    end
  end

  # Создаем массив для хранения последовательности операций
  sequence = []
  # Указатель на текущую позицию (начинаем с конца)
  i = n
  # Флаг для отслеживания использования удвоения при восстановлении
  double_used = false

  # Восстанавливаем последовательность операций
  while i > 0
    # Проверяем возможность операции удвоения
    if !double_used && i.even?
      # Вычисляем половину длины
      half = i / 2
      # Флаг для проверки возможности удвоения
      can_double = true
      
      # Проверяем совпадение символов
      (0...half).each do |j|
        if chars[j] != chars[half + j]
          can_double = false
          break
        end
      end
      
      # Если операция удвоения была использована
      if can_double && dp[i] == dp[half] + 1
        # Создаем описание операции
        op_desc = "Удвоение (получено '"
        (0...i).each { |k| op_desc << chars[k] }
        op_desc << "')"
        
        # Добавляем операцию в начало массива
        sequence.unshift(op_desc)
        # Переходим к строке до удвоения
        i = half
        # Помечаем удвоение как использованное
        double_used = true
        next
      end
    end
    
    # Создаем описание операции добавления символа
    op_desc = "Добавлен '#{chars[i - 1]}'"
    
    # Добавляем операцию в начало массива
    sequence.unshift(op_desc)
    # Переходим к предыдущему символу
    i -= 1
  end

  # Возвращаем результат: количество операций и последовательность
  [dp[n], sequence]
end

# Основная часть программы
print "Введите целевую строку: "
target = gets.chomp

# Вычисляем результат
steps, sequence = min_operations(target)

# Выводим минимальное количество операций
puts "Минимальное количество операций: #{steps}"

# Выводим заголовок для последовательности операций
puts "Последовательность:"

# Выводим каждую операцию с нумерацией
sequence.each_with_index { |step, i| puts "#{i + 1}. #{step}" }