use std::io;

// Функция для вычисления минимального количества операций и последовательности их выполнения
fn min_operations(target: &str) -> (usize, Vec<String>) {
    let n = target.len(); // Длина целевой строки
    let mut dp = vec![0; n + 1]; // Вектор для хранения минимальных операций для каждой префикс-строки
    let mut used_double = false; // Флаг, показывающий, использовали ли уже операцию удвоения

    // Проходим по всем префиксам строки
    for i in 1..=n {
        // Изначально предполагаем, что последняя операция — добавление последнего символа
        dp[i] = dp[i - 1] + 1;

        // Проверяем возможность операции удвоения
        if !used_double && i % 2 == 0 && target[..i/2] == target[i/2..i] {
            // Если есть возможность удвоить и это уменьшит число операций
            if dp[i / 2] + 1 < dp[i] {
                dp[i] = dp[i / 2] + 1; // Обновляем минимальное число операций
                used_double = true; // Помечаем, что удвоение уже использовано
            }
        }
    }

    // Восстановление последовательности операций
    let mut sequence = Vec::new();
    let mut i = n; // Индекс текущего положения, начинаем с конца
    let mut double_used = false; // Флаг, использовали ли операцию удвоения
    let chars: Vec<char> = target.chars().collect(); // Преобразуем строку в массив символов для удобства
    
    // Обратный проход по строке для восстановления последовательности
    while i > 0 {
        // Проверка, было ли последнее действие удвоением
        if !double_used && i % 2 == 0 && chars[..i/2] == chars[i/2..i] && dp[i] == dp[i/2] + 1 {
            // Если условие выполнено, добавляем в последовательность операцию удвоения
            sequence.push(format!("Удвоение (получено '{}')", &target[..i]));
            i /= 2; // Переходим к предыдущему состоянию
            double_used = true; // Отмечаем, что удвоение использовано
        } else {
            // Иначе — добавление символа
            sequence.push(format!("Добавлен '{}'", chars[i - 1]));
            i -= 1; // Переходим к предыдущему символу
        }
    }

    sequence.reverse(); // Обратный порядок, так как прошли с конца
    (dp[n], sequence) // Возвращаем минимальное число операций и последовательность их выполнения
}

fn main() {
    println!("Введите целевую строку:");
    let mut target = String::new();
    io::stdin().read_line(&mut target).unwrap(); // Чтение строки с пользовательским вводом
    let target = target.trim(); // Убираем лишние пробелы и переносы строк
    
    let (steps, sequence) = min_operations(target); // Вычисляем результат
    println!("Минимальное количество операций: {}", steps); // Выводим результат
    println!("Последовательность:");
    for (i, step) in sequence.iter().enumerate() {
        println!("{}. {}", i + 1, step); // Выводим каждую операцию с номером
    }
}
