def min_operations(target):
    # Получаем длину целевой последовательности
    n = len(target)
    
    # Создаем список для хранения минимального количества операций
    dp = []
    # Инициализируем список значениями от 0 до n
    for i in range(n + 1):
        dp.append(i)
    
    # Флаг для отслеживания использования операции удвоения
    used_double = False

    # Заполняем список dp значениями
    for i in range(1, n + 1):
        # Базовый случай - добавление одного символа
        dp[i] = dp[i - 1] + 1
        
        # Проверяем возможность операции удвоения
        if not used_double and i % 2 == 0:
            # Флаг для проверки возможности удвоения
            can_double = True
            # Вычисляем половину длины
            half = i // 2
            
            # Проверяем совпадение символов в двух половинах
            for j in range(half):
                if target[j] != target[half + j]:
                    can_double = False
                    break
            
            # Если можно удвоить и это выгодно
            if can_double and dp[half] + 1 < dp[i]:
                # Обновляем значение в dp
                dp[i] = dp[half] + 1
                # Помечаем удвоение как использованное
                used_double = True

    # Создаем список для хранения последовательности операций
    sequence = []
    # Указатель на текущую позицию (начинаем с конца)
    i = n
    # Флаг для отслеживания использования удвоения при восстановлении
    double_used = False

    # Восстанавливаем последовательность операций
    while i > 0:
        # Проверяем возможность операции удвоения
        if not double_used and i % 2 == 0:
            # Вычисляем половину длины
            half = i // 2
            # Флаг для проверки возможности удвоения
            can_double = True
            
            # Проверяем совпадение символов
            for j in range(half):
                if target[j] != target[half + j]:
                    can_double = False
                    break
            
            # Если операция удвоения была использована
            if can_double and dp[i] == dp[half] + 1:
                # Создаем описание операции
                op_desc = "Удвоение (получено '"
                for k in range(i):
                    op_desc += target[k]
                op_desc += "')"
                
                # Добавляем операцию в начало списка
                sequence.insert(0, op_desc)
                # Переходим к строке до удвоения
                i = half
                # Помечаем удвоение как использованное
                double_used = True
                continue
        
        # Создаем описание операции добавления символа
        op_desc = "Добавлен '" + target[i - 1] + "'"
        
        # Добавляем операцию в начало списка
        sequence.insert(0, op_desc)
        # Переходим к предыдущему символу
        i -= 1

    # Возвращаем результат: количество операций и последовательность
    return dp[n], sequence

# Основная часть программы
if __name__ == "__main__":
    # Запрашиваем ввод у пользователя
    target = input("Введите целевую строку: ")
    
    # Вычисляем результат
    steps, sequence = min_operations(target)
    
    # Выводим минимальное количество операций
    print(f"Минимальное количество операций: {steps}")
    
    # Выводим заголовок для последовательности операций
    print("Последовательность:")
    
    # Выводим каждую операцию с нумерацией
    for i, action in enumerate(sequence, 1):
        print(f"{i}. {action}")